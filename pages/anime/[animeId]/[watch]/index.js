import Head from "next/head";
import React, { Fragment, useMemo } from "react";
import VideoPlayerWithEpisodeInfo from "../../../../components/watch-page/VideoPlayerWithEpisodeInfo";
import Row from "../../../../components/home-page/Row";

export const AnimeContext = React.createContext();

function AnimeStream({ animeInfo, episodes, episodeStreamingLinks }) {
    const relatedAnime = useMemo(
        () =>
            animeInfo.relations.filter(
                (element) => element.status.toLowerCase() === "completed"
            ),
        [animeInfo.relations]
    );

    return (
        <Fragment>
            <Head>
                <title>{`Watch ${
                    animeInfo.title.english ||
                    animeInfo.title.romaji ||
                    animeInfo.title.native
                } | Animflix`}</title>
                <meta
                    name="description"
                    content="Generated by create next app"
                />
                <link rel="icon" href="/favicon.ico" />
            </Head>

            <AnimeContext.Provider
                value={{
                    animeInfo,
                    episodes,
                    episodeStreamingLinks,
                }}
            >
                <main className="relative min-h-screen max-w-[1920px] m-auto overflow-x-hidden pb-[4em]">
                    <VideoPlayerWithEpisodeInfo />

                    <section className="space-y-[5em]">
                        {episodes.length > 1 && (
                            <Row
                                title="Episodes"
                                data={episodes}
                                type="Episode"
                            />
                        )}

                        {/* Shows related to the anime you're currently playing */}
                        {relatedAnime.length > 0 && (
                            <Row
                                title="Related"
                                data={relatedAnime}
                                type="Card"
                            />
                        )}
                        {animeInfo.recommendations.length > 0 && (
                            <Row
                                title="Recommended Shows"
                                data={animeInfo.recommendations}
                                type="Card"
                            />
                        )}
                    </section>
                </main>
            </AnimeContext.Provider>
        </Fragment>
    );
}

export default AnimeStream;

export async function getServerSideProps(context) {
    const {
        params: { animeId },
        query: { v: episodeId },
    } = context;

    const [animeInfo, episodeStreamingLinks] = await Promise.all([
        fetch(`${process.env.NEXT_PUBLIC_BASE_API_PATH}/info/${animeId}`).then(
            (res) => res.json()
        ),
        fetch(`${process.env.NEXT_PUBLIC_STREAMING_PATH}/${episodeId}`).then(
            (res) => res.json()
        ),
    ]);

    return {
        props: {
            animeInfo,
            episodes: animeInfo.episodes.map((element) => {
                if (element.id) {
                    return element;
                }
            }),
            episodeStreamingLinks,
        },
    };
}

AnimeStream.getLayout = function PageLayout(page) {
    return page;
};
